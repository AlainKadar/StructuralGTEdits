"""skel_ID: A collection of methods and tools for analyzing
and altering a skeletal image.  Prepares the skeleton for
conversion into a graph object.

Copyright (C) 2021, The Regents of the University of Michigan.

This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Contributers: Drew Vecchio, Samuel Mahler, Mark D. Hammig, Nicholas A. Kotov
Contact email: vecdrew@umich.edu
"""

from __main__ import *

import numpy as np
from scipy import ndimage
from skimage.morphology import skeletonize
from skimage.morphology import disk, remove_small_objects
from skimage.morphology import binary_dilation as dilate

import skel_features as sk
import os

# Return a sparse 3D array with 1s at the locations of branch points. Branch point features defined by 3x3x3 array
# and generated by skel_features.py
def branchedPoints(skel):
    # Defin rotationally independent features
    x_base = np.array([[0,0,0],
                     [-1,1,0],
                     [-1,-1,0],
                      [1,1,0],
                      [1,-1,0]])

    t_base = np.array([[0,0,0],
                      [-1,0,0],
                      [1,0,0],
                      [0,1,0]])

    y_base = np.array([[0,0,0],
                     [-1,1,0],
                     [1,1,0],
                     [0,-1,0]])

    names = ("cross","tee","y")
    bases = (x_base, t_base, y_base)

    for name,base  in zip(names,bases):
        sk.write_feature(base, name)

    br = 0
    for FeatName in os.listdir("feature_lib"):
        ArrList = np.load("feature_lib/" + FeatName)
        for Array in ArrList:
            br = br + ndimage.binary_hit_or_miss(skel, Array)

    return br

def endPoints(skel):
    # finding all the locations of the endpoints
    ep1 = ndimage.binary_hit_or_miss(skel, endpoint1)
    ep2 = ndimage.binary_hit_or_miss(skel, endpoint2)
    ep3 = ndimage.binary_hit_or_miss(skel, endpoint3)
    ep4 = ndimage.binary_hit_or_miss(skel, endpoint4)
    ep5 = ndimage.binary_hit_or_miss(skel, endpoint5)
    ep6 = ndimage.binary_hit_or_miss(skel, endpoint6)
    ep7 = ndimage.binary_hit_or_miss(skel, endpoint7)
    ep8 = ndimage.binary_hit_or_miss(skel, endpoint8)
    ep9 = ndimage.binary_hit_or_miss(skel, endpoint9)
    ep = ep1 + ep2 + ep3 + ep4 + ep5 + ep6 + ep7 + ep8 + ep9
    return ep

def pruning(skeleton, size, Bps):
    branchpoints = Bps
    #remove iteratively end points "size" times from the skeleton
    for i in range(0, size):
        endpoints = endPoints(skeleton)
        points = np.logical_and(endpoints, branchpoints)
        endpoints = np.logical_xor(endpoints, points)
        endpoints = np.logical_not(endpoints)
        skeleton = np.logical_and(skeleton,endpoints)
    return skeleton


def merge_nodes(skeleton):

    # overlay a disk over each branch point and find the overlaps to combine nodes
    skeleton_integer = 1 * skeleton
    radius = 2
    mask_elem = disk(radius)
    BpSk = branchedPoints(skeleton_integer)
    BpSk = 1*(dilate(BpSk, mask_elem))

    # widenodes is initially an empty image the same size as the skeleton image
    sh = skeleton_integer.shape
    widenodes = np.zeros(sh, dtype='int')

    # this overlays the two skeletons
    # skeleton_integer is the full map, BpSk is just the branch points blown up to a larger size
    for x in range(sh[0]):
        for y in range(sh[1]):
            if skeleton_integer[x, y] == 0 and BpSk[x, y] == 0:
                widenodes[x, y] = 0
            else:
                widenodes[x, y] = 1

    # reskeletonzing widenodes and returning it, nearby nodes in radius 2 of each other should have been merged
    newskel = skeletonize(widenodes)
    return newskel

def make_skel(img_bin, merge, prune, clean, r_size):
    
    #Change from master: img_bin is now a stack of 2D .tiffs
    skeleton=[]
    skel_int=[]
    Bp=[]
    Ep=[]
    i=0
    for plane in img_bin:
        # making the initial skeleton image, then getting x and y coords of all branch points and endpoints
        plane = (plane/255).astype(np.bool)
        skeleton.append(skeletonize(plane))
        skel_int.append(1*skeleton[i])
        Bp.append(branchedPoints(skel_int[i]))
        Ep.append(endPoints(skel_int[i]))
        i+=1

    Bp_coord_z, Bp_coord_y, Bp_coord_x = np.where(Bp == 1)
    Ep_coord_z, Ep_coord_y, Ep_coord_x = np.where(Ep == 1)

    # calling the three functions for merging nodes, pruning edges, and removing disconnected segments
    if(merge == 1):
        skeleton = merge_nodes(skeleton)

    if(clean == 1):
        skeleton = remove_small_objects(skeleton, r_size, connectivity=2)

    skel_int = 1*skeleton

    Bps = branchedPoints(skel_int)

    if(prune == 1):
        skeleton = pruning(skeleton, 500, Bps)


    clean_skel = skeleton
    return clean_skel, skel_int, Bp_coord_x, Bp_coord_y, Bp_coord_z, Ep_coord_x, Ep_coord_y, Ep_coord_z
