"""skel_ID: A collection of methods and tools for analyzing
and altering a skeletal image.  Prepares the skeleton for
conversion into a graph object.

Copyright (C) 2021, The Regents of the University of Michigan.

This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Contributers: Drew Vecchio, Samuel Mahler, Mark D. Hammig, Nicholas A. Kotov
Contact email: vecdrew@umich.edu
"""

from __main__ import *

import numpy as np
from scipy import ndimage
from skimage.morphology import skeletonize
from skimage.morphology import disk, remove_small_objects
from skimage.morphology import binary_dilation as dilate

from StructuralGT import skel_features as sk
from StructuralGT import base
import os
import shutil
import gsd.hoomd

# Return a sparse 3D array with 1s at the locations of branch points. Branch point features defined by 3x3x3 array
# and generated by skel_features.py
def branchedPoints(skel):
    # Defin rotationally independent features
    x_base = np.array([[0,0,0],
                     [-1,1,0],
                     [-1,-1,0],
                      [1,1,0],
                      [1,-1,0]])

    t_base = np.array([[0,0,0],
                      [-1,0,0],
                      [1,0,0],
                      [0,1,0]])

    y_base = np.array([[0,0,0],
                     [-1,1,0],
                     [1,1,0],
                     [0,-1,0]])

    names = ("cross","tee","y")
    bases = (x_base, t_base, y_base)

    for name,base  in zip(names,bases):
        sk.write_feature(base, name, "branch_lib")

    br = 0
    for FeatName in os.listdir("branch_lib"):
        ArrList = np.load("branch_lib/" + FeatName)
        for Array in ArrList:
            br = br + ndimage.binary_hit_or_miss(skel, Array)

    return np.where(br != 0)

def endPoints(skel):

    end_base = np.array([[0,0,0],
                        [ 0,0,1]])

    sk.write_feature(end_base, "end", "end_lib")

    ep = 0
    ArrList = np.load("end_lib/end.npy")
    for Array in ArrList:
        ep = ep + ndimage.binary_hit_or_miss(skel, Array)

    return np.where(ep != 0).T

def pruning(skeleton, size, Bps):
    branchpoints = Bps
    #remove iteratively end points "size" times from the skeleton
    for i in range(0, size):
        endpoints = endPoints(skeleton)
        points = np.logical_and(endpoints, branchpoints)
        endpoints = np.logical_xor(endpoints, points)
        endpoints = np.logical_not(endpoints)
        skeleton = np.logical_and(skeleton,endpoints)
    return skeleton


def merge_nodes(skeleton):

    # overlay a disk over each branch point and find the overlaps to combine nodes
    skeleton_integer = 1 * skeleton
    radius = 2
    mask_elem = disk(radius)
    BpSk = branchedPoints(skeleton_integer)
    BpSk = 1*(dilate(BpSk, mask_elem))

    # widenodes is initially an empty image the same size as the skeleton image
    sh = skeleton_integer.shape
    widenodes = np.zeros(sh, dtype='int')

    # this overlays the two skeletons
    # skeleton_integer is the full map, BpSk is just the branch points blown up to a larger size
    for x in range(sh[0]):
        for y in range(sh[1]):
            if skeleton_integer[x, y] == 0 and BpSk[x, y] == 0:
                widenodes[x, y] = 0
            else:
                widenodes[x, y] = 1

    # reskeletonzing widenodes and returning it, nearby nodes in radius 2 of each other should have been merged
    newskel = skeletonize(widenodes)
    return newskel

# Instead of returning skeletons and feature points coordinates, this returns skeletons but writes the features (and skeleton) to gsd
# Note that 'coord' suffix indicates the variable is a list of coordinates. Otherwise, data representing skeletons/features is a sparse array
def make_skel(params, aspect, merge, prune, clean, r_size):
    
    #Change from master: img_bin is now a stack of 2D .tiffs
    img_bin = []
    i=0
    for name in sorted(os.listdir(params['directory']+'/Binarized')):
        if base.Q_img(name):
            img_slice = cv.imread(params['directory']+'/Binarized/slice'+str(i)+'.tiff',cv.IMREAD_GRAYSCALE)
            img_bin.append(img_slice)
            i=i+1
        else:
            pass

    skeleton = skeletonize_3d(np.asarray(img_bin)/255).astype(int)

    branch_coords = branchedPoints(skeleton)
    end_coords = endPoints(skeleton)
    skel_coords = np.asarray(np.where(skeleton!=0)) #Outputs array with shape (3,N)
    

    for feature in (skel_coords, branch_coords, end_coords):
        for i in (0,1,2):
            feature[i] = feature[i]*aspect[i]
    feature = feature.T
    sd_coords = np.setdiff1d(skel_coords,branch_coords).reshape(-1, skel.shape[1])    
    print(skel_coords)
    print(end_coords)
    s = gsd.hoomd.snapshot()
    with gsd.hoomd.open(name=params['save_name']+'_raw.gsd', mode='wb') as f:
        s.particles.N = np.shape(skel_coords)[0] + np.shape(branch_coords)[0] + np.shape(end_coords)[0]
        s.particles.position = skel_coords
        f.append(s)

#    with gsd.hoomd.open(name=params['save_name']+'_cleaned.gsd', mode='wb') as f:
#        pass


    # calling the three functions for merging nodes, pruning edges, and removing disconnected segments
    if(merge == 1):
        skeleton = merge_nodes(skeleton)

    if(clean == 1):
        skeleton = remove_small_objects(skeleton, r_size, connectivity=2)

    skel_int = 1*skeleton

    Bps = branchedPoints(skel_int)

    if(prune == 1):
        skeleton = pruning(skeleton, 500, Bps)


    clean_skel = skeleton
    return clean_skel, skel_int, Bp_coord_x, Bp_coord_y, Bp_coord_z, Ep_coord_x, Ep_coord_y, Ep_coord_z
